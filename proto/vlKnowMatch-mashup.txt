vlMatch [vtL_Design] emptyBinding S.empty S.empty
        (vwrap [ok] ++ lwrap [lS]) (lwrap [lO])
=
*** Exception: user error (vlKnownMatch(mashup): NYI
-----------
vlC  =  [GV (VR (Id "ok",VO,WB)),GL (LV (VR (Id "S",VO,WB),[],[]))]
::
gvP  =  GL (LV (VR (Id "O",VO,WB),[],[]))
---
vlK  =  [GL (LV (VR (Id "M",VO,WB),[],[])),GL (LV (VR (Id "S",VO,WB),[],[]))]
vlX  =  [VR (Id "ok",VO,WB),VR (Id "x",VO,WB),VR (Id "y",VO,WB),VR (Id "z",VO,WB)]
xLen =  4
uis  =  []
ujs  =  []
)
 Pulls ok off vlC, matches head vlX:
    so keep ok, and tail vlX
 Pulls S off vlC, expands to tail vlX, is prefix of vlX:
    so keep S, and drop xyz off vlX.
 vlX is empty, so return ok,S   with vlC empty



vlMatch [vtL_Design] emptyBinding S.empty S.empty
        (vwrap [x,y,z]) (vwrap [vu] ++ lwrap [lSu])
=
*** Exception: user error (vlKnownMatch(mashup): NYI
-----------
vlC  =  [GV (VR (Id "y",VO,WB)),GV (VR (Id "z",VO,WB))]
::
gvP  =  GL (LV (VR (Id "S",VO,WB),[Id "u"],[]))
---
vlK  =  [GV (VR (Id "x",VO,WB)),GV (VR (Id "y",VO,WB)),GV (VR (Id "z",VO,WB))]
vlX  =  [VR (Id "x",VO,WB),VR (Id "y",VO,WB),VR (Id "z",VO,WB)]
xLen =  3
uis  =  [Id "u"]
ujs  =  []
)

 Pulls y off vlC
 Does not match head vlX, but uis is non-empty, so record u -> x, tailing vlX
 Still with y, does match head vlX:
   so keep y, tail vlX
 Pull z off vlC, matches head vlX:
    so keep z, tail vlX
 vlX empty so return y,z   with  vlC empty

vlMatch [vtL_Design] emptyBinding S.empty S.empty
        (vwrap [y,z,x]) (lwrap [lSu] ++ vwrap [vu])
=
*** Exception: user error (vlKnownMatch(mashup): NYI
-----------
vlC  =  [GV (VR (Id "y",VO,WB)),GV (VR (Id "z",VO,WB)),GV (VR (Id "x",VO,WB))]
::
gvP  =  GL (LV (VR (Id "S",VO,WB),[Id "u"],[]))
---
vlK  =  [GV (VR (Id "x",VO,WB)),GV (VR (Id "y",VO,WB)),GV (VR (Id "z",VO,WB))]
vlX  =  [VR (Id "x",VO,WB),VR (Id "y",VO,WB),VR (Id "z",VO,WB)]
xLen =  3
uis  =  [Id "u"]
ujs  =  []
)

 Pulls y off vlC
 Does not match head vlX, but uis is non-empty, so record u -> x, tailing vlX
 Still with y, does match head vlX:
   so keep y, tail vlX
 Pull z off vlC, matches head vlX:
    so keep z, tail vlX
 vlX empty so return y,z   with  vlC = [x]

vlMatch [vtL_Design] emptyBinding S.empty S.empty
        (vwrap [x,y,z]) (vwrap [vu,vw] ++ lwrap [lSuw])
=
*** Exception: user error (vlKnownMatch(mashup): NYI
-----------
vlC  =  [GV (VR (Id "z",VO,WB))]
::
gvP  =  GL (LV (VR (Id "S",VO,WB),[Id "u",Id "w"],[]))
---
vlK  =  [GV (VR (Id "x",VO,WB)),GV (VR (Id "y",VO,WB)),GV (VR (Id "z",VO,WB))]
vlX  =  [VR (Id "x",VO,WB),VR (Id "y",VO,WB),VR (Id "z",VO,WB)]
xLen =  3
uis  =  [Id "u",Id "w"]
ujs  =  []
)

Pulls z off vlC
Does not match head vlX, but uis is non-empty,
   so record u -> x, tailing vlX, uis
Still with z
Does not match head vlX, but uis is non-empty,
   so record w -> y, tailing vlX, uis
Still with z
Matches head vlX:
  so keep z, tail vlX
vlX empty, so return z  with vlC empty

Summary
  REPEAT
    pull head off vlC, if unknown list variable then FAIL, expand if known listvar
    LOOP
      is head/expansion a prefix of vlX?
       Yes: keep head(vlC), drop prefix from vlX, tail vlC, set expansion to null
       No: are uis and ujs both null? If so, FAIL
           if uis not null
           then
              BIND head uis to head expansion, tail expansion, uis
           else -- uis null, ujs not null
              BIND head ujs to head expansion, tail expansion, uis
              -- not the smartest, should really try 1,2,3 bits of expansion
    EXIT if null expansion or uis and ujs are null
    if not null expansion then FAIL
  UNTIL vlX or vlC are empty
  if vlX empty then return gvP -> list of kept vlC variables, rest of vlC
  if not, FAIL (vlC is empty)


--
