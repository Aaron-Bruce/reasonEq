BEGIN REQSTATE
BEGIN REQSET
MMD = 20
END REQSET
BEGIN SIGNATURE
TRUE = K P (VB True)
FALSE = K P (VB False)
EQV = Id "equiv"
IMP = Id "implies"
AND = Id "land"
END SIGNATURE
BEGIN THEORIES
THNAMES = ["Equality","PredAxioms","PredExists","PredUniv","PropAxioms","PropConj","PropDisj","PropEquiv","PropImpl","PropMixOne","PropNot","PropSubst","UTPStartup","XYZ","XYZDesign"]
SDAG = [[("XYZDesign",["UTPStartup","PredUniv","PredExists","PredAxioms","Equality","PropSubst","PropImpl","PropMixOne","PropConj","PropDisj","PropNot","PropEquiv","PropAxioms"]),("XYZ",["UTPStartup","PredUniv","PredExists","PredAxioms","Equality","PropSubst","PropImpl","PropMixOne","PropConj","PropDisj","PropNot","PropEquiv","PropAxioms"])],[("UTPStartup",["PredUniv","PredExists","PredAxioms","Equality","PropSubst","PropImpl","PropMixOne","PropConj","PropDisj","PropNot","PropEquiv","PropAxioms"])],[("PredUniv",["PredExists","PredAxioms","Equality","PropSubst","PropImpl","PropMixOne","PropConj","PropDisj","PropNot","PropEquiv","PropAxioms"])],[("PredExists",["PredAxioms","Equality","PropSubst","PropImpl","PropMixOne","PropConj","PropDisj","PropNot","PropEquiv","PropAxioms"])],[("PredAxioms",["Equality","PropSubst","PropImpl","PropMixOne","PropConj","PropDisj","PropNot","PropEquiv","PropAxioms"])],[("PropSubst",["PropImpl","PropConj","PropDisj","PropNot","PropEquiv","PropAxioms"])],[("PropImpl",["PropMixOne","PropConj","PropDisj","PropNot","PropEquiv","PropAxioms"])],[("PropMixOne",["PropConj","PropDisj","PropNot","PropEquiv","PropAxioms"])],[("PropConj",["PropDisj","PropNot","PropEquiv","PropAxioms"])],[("PropDisj",["PropNot","PropEquiv","PropAxioms"])],[("PropNot",["PropEquiv","PropAxioms"])],[("Equality",["PropAxioms"]),("PropEquiv",["PropAxioms"])],[("PropAxioms",[])]]
END THEORIES
CURRTHEORY = PropImpl
BEGIN LIVE-PROOFS
BEGIN MAP LIVE-PROOFS
("PropImpl","implies_equiv_distr")
BEGIN LIVE-PROOF
TH-NAME: PropImpl
CJ-NAME: implies_equiv_distr
CONJ = (C P (Id "equiv") [C P (Id "implies") [V P (VR (Id "P",VP,WS)),C P (Id "equiv") [V P (VR (Id "Q",VP,WS)),V P (VR (Id "R",VP,WS))]],C P (Id "equiv") [C P (Id "implies") [V P (VR (Id "P",VP,WS)),V P (VR (Id "Q",VP,WS))],C P (Id "implies") [V P (VR (Id "P",VP,WS)),V P (VR (Id "R",VP,WS))]]],[])
SIDE = []
STRAT reduce
BEGIN SEQZIP
TERMZIP = (C P (Id "equiv") [C P (Id "implies") [V P (VR (Id "P",VP,WS)),C P (Id "equiv") [V P (VR (Id "Q",VP,WS)),V P (VR (Id "R",VP,WS))]],C P (Id "equiv") [C P (Id "implies") [V P (VR (Id "P",VP,WS)),V P (VR (Id "Q",VP,WS))],C P (Id "implies") [V P (VR (Id "P",VP,WS)),V P (VR (Id "R",VP,WS))]]],[])
BEGIN SEQUENT'
SIDECOND = []
LAWS' = CLaws' {hyp0 = Theory {thName = "H.implies_equiv_distr", thDeps = [], known = VD (fromList [],fromList [],fromList []), laws = [], proofs = [], conjs = []}, whichC = Lft, otherC = K P (VB True)}
END SEQUENT'
END SEQZIP
FPATH: []
BEGIN LIST STEPS
END LIST STEPS
END LIVE-PROOF
END MAP LIVE-PROOFS
END LIVE-PROOFS
END REQSTATE
